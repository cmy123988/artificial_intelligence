# 波士顿房价数据分析--随机森林填补数据缺失

## 实验准备

安装所需要的库：sklearn

参考[Introduction · sklearn 中文文档 (apachecn.org)](https://sklearn.apachecn.org/)进行安装

安装这个库之前需要先行安装numpy和scipy，参考[Numpy及Scipy的安装](https://blog.csdn.net/qq_36560826/article/details/104826111?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&spm=1001.2101.3001.4242)发现不能直接pip安装，需要去https://www.lfd.uci.edu/~gohlke/pythonlibs里安装.whl文件

需要安装自己的python和电脑系统对应的版本

```
python --version#查看python版本
pip debug --verbose#查看自己能安装的版本
```

注意更新自己的pip

然后把下载好的文件放到在python的安装目录下面scripts文件夹下，打开powershell，参考[最详细的NumPy安装流程](https://blog.csdn.net/sinat_26933727/article/details/68953193)在命令行中输入

```
 pip install \**.whl #你的whl文件所在路径 \ xxx.whl
```

进行安装

安装完成后可以import一下，没有消息就是最好的消息，安装完成

## 实验原理

将对波士顿房价的原始数据进行处理，在数据中人为添加一些缺失值，然后根据分三种情况：①用0填补缺失值，②均值填补，③用随机森林填补，之后分别构建随机森林回归，计算MSE，并做可视化。

#### 随机森林回归计算缺失值思路

任何回归都是从特征矩阵中学习，然后求解连续型标签y的过程，之所以能够实现这个过程，是因为回归算法认为，特征矩阵和标签之间存在着某种联系。而且标签和特征矩阵是可以相互转换的，比如说，在一个“用地区，环境，附近学校数量”预测“房价”的问题中，我们既可以用“地区”，“环境”，“附近学校数量”的数据来预测“房价”，也可以反过来，用“环境”，“附近学校数量”和“房价”来预测“地区”。而回归填补缺失值，正是利用了这种思想。

对于一个有n个特征的数据集，如果

**1.某一个特征大量缺失，其他特征却很完整**

只有特征T有缺失值，我们就把特征T当作标签，其他的n-1个特征和原本的标签组成新的特征矩阵。那对于T来说，它没有缺失的部分，就是我们的Y_test，这部分数据既有标签也有特征，而它缺失的部分，只有特征没有标签，就是我们需要预测的部分。

**2.其他特征也有缺失**

遍历所有的特征，从缺失最少的开始进行填补（因为填补缺失最少的特征所需要的准确信息最少）。填补一个特征时，先将其他特征的缺失值用0代替，每完成一次回归预测，就将预测值放到原本的特征矩阵中，再继续填补下一个特征。每一次填补完毕，有缺失值的特征会减少一个，所以每次循环后，需要用0来填补的特征就越来越少。当进行到最后一个特征时（这个特征应该是所有特征中缺失值最多的），已经没有任何的其他特征需要用0来进行填补了，而我们已经使用回归为其他特征填补了大量有效信息，可以用来填补缺失最多的特征。遍历所有的特征后，数据就完整，不再有缺失值了。


## 实验步骤

导入相应包

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.datasets import load_boston
from sklearn.impute import SimpleImputer
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import cross_val_score

```

准备数据集

```
dataset = load_boston()
X_full, y_full = dataset.data, dataset.target

```

对数据集设置50%缺失值

```
#样本数和特征数
n_samples = X_full.shape[0]
n_features = X_full.shape[1]
#首先确定我们希望放入的缺失数据的比例，在这里我们假设是50%
rng = np.random.RandomState(0)
#缺失率
missing_rate = 0.5
#应确实总数
n_missing_samples = int(np.floor(n_samples * n_features * missing_rate))
#通过随机数设置这n_missing_samples个缺失值的横纵索引
missing_features = rng.randint(0, n_features, n_missing_samples)
missing_samples = rng.randint(0, n_samples, n_missing_samples)
#保留原数据
X_missing = X_full.copy()
y_missing = y_full.copy()
#设置缺失值np.nan并转换为DataFrame格式
X_missing[missing_samples, missing_features] = np.nan
X_missing = pd.DataFrame(X_missing)

```

均值代替缺失值

```
#设置SimpleImputer利用均值填充
imp_mean = SimpleImputer(missing_values=np.nan, strategy='mean')
X_missing_mean = imp_mean.fit_transform(X_missing)

```

零代替缺失值

```
#设置SimpleImputer利用0填充
imp_0 = SimpleImputer(missing_values=np.nan, strategy='constant', fill_value=0)
X_missing_0 = imp_0.fit_transform(X_missing)

```

随机森林回归计算缺失值

```
X_missing_reg = X_missing.copy()
#利用np.argsort将数据按每列的缺失值进行排序并获取排序索引
sortindex = np.argsort(X_missing_reg.isnull().sum(axis=0)).values
#依次遍历每个索引
for i in sortindex:
    #构建我们的新特征矩阵和新标签
    df = X_missing_reg
    #需要填补的列
    fillc = df.iloc[:,i]
    #将除i以外的列以及房价y列合并作为训练集
    df = pd.concat([df.iloc[:, df.columns != i], pd.DataFrame(y_full)], axis=1)
    #将训练集缺失值部分取0
    df_0 = imp_0.fit_transform(df)

    #划分训练测试集
    Ytrain = fillc[fillc.notnull()]
    Ytest = fillc[fillc.isnull()]
    Xtrain = df_0[Ytrain.index, :]
    Xtest = df_0[Ytest.index, :]
    #构造随机森林
    rfc = RandomForestRegressor(n_estimators=25)
    rfc.fit(Xtrain, Ytrain)
    #预测并将值保存到原始矩阵中
    Ypredict = rfc.predict(Xtest)
    X_missing_reg.loc[X_missing_reg.iloc[:, i].isnull(), i] = Ypredict

```

统计建模分析

```
#进行建模分析
X = [X_full, X_missing_mean, X_missing_0, X_missing_reg]
mse = []
std = []
#一次对三种情况与原始数据进行预测评估
for x in X:
    estimator = RandomForestRegressor(random_state=0, n_estimators=50)
    score = cross_val_score(estimator, x, y_full, scoring='neg_mean_squared_error', cv=5).mean()
    #注意上述score为负MSE，需要×-1
    mse.append(score * -1)

```

数据可视化

```
#可视化
x_labels = ['Full data', 'Zero Imputation', 'Mean Imputation', 'Regressor Imputation']
colors = ['r', 'g', 'b', 'orange']
plt.figure(figsize=(12, 6))
ax = plt.subplot(111)
for i in np.arange(len(mse)):
	#水平条形图将数据依次遍历画出
    ax.barh(i, mse[i], color=colors[i], alpha=0.6, align='center')
ax.set_title('Imputation Techniques with Boston Data')
#设置x轴坐标上下限
ax.set_xlim(left=np.min(mse) * 0.9, right=np.max(mse) * 1.1)
#y轴刻度
ax.set_yticks(np.arange(len(mse)))
#x轴标签
ax.set_xlabel('MSE')
#y轴每个刻度的标签
ax.set_yticklabels(x_labels)
plt.show()

```

## 实验结论

利用随机森林回归填补的缺失值与其他填补方式MSE小，甚至比原始值的MSE误差小